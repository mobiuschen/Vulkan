// Copyright 2020 Google LLC

[[vk::constant_id(0)]] const float MIN_CULL_DISTANCE = 10.0;

struct InstanceData
{
	float4 transRow0;
	float4 transRow1;
	float4 transRow2;
	float4 transRow3;
	uint primIndex;
	float _pad0;
	float _pad1;
	float _pad2;
};

struct PrimitiveData {
	float4x4 transform;
	float cullDistance;
	uint firstIndex;
	uint indexCount;
	uint materialIndex;
};

// Same layout as VkDrawIndexedIndirectCommand
struct IndexedIndirectCommand
{
	uint indexCount;
	uint instanceCount;
	uint firstIndex;
	uint vertexOffset;
	uint firstInstance;
};

struct View
{
	float4x4 projection;
	float4x4 modelview;
	float4 cameraPos;
	float4 frustumPlanes[6];
};

// struct Stat
// {
// 	uint drawCount;
// 	uint lodCount[MAX_LOD_LEVEL_COUNT];
// };

// struct LOD
// {
// 	uint firstIndex;
// 	uint indexCount;
// 	float distance;
// 	float _pad0;
// };

StructuredBuffer<InstanceData> instances : register(t0);
RWStructuredBuffer<IndexedIndirectCommand> indirectDraws : register(u1);
// Binding 2: Uniform block object with matrices
cbuffer view : register(b2) { View view; }
// Binding 3: Indirect draw stats
//RWStructuredBuffer<Stat> stat : register(u3);
// Binding 4: level-of-detail information
//StructuredBuffer<LOD> lods : register(t4);
StructuredBuffer<PrimitiveData> primitives : register(t3);

[numthreads(16, 1, 1)]
bool frustumCheck(float4 pos, float radius)
{
	// Check sphere against frustum planes
	for (int i = 0; i < 6; i++)
	{
		if (dot(pos, view.frustumPlanes[i]) + radius < 0.0)
		{
			return false;
		}
	}
	return true;
}

[numthreads(16, 1, 1)]
void main(uint3 GlobalInvocationID : SV_DispatchThreadID )
{
	uint idx = GlobalInvocationID.x;
	uint temp;

	// float4 pos = float4(instances[idx].pos.xyz, 1.0);
	const uint primIdx = instances[idx].primIndex;
	float4x4 insMat;
	insMat[0] = instances[idx].transRow0;
	insMat[1] = instances[idx].transRow1;
	insMat[2] = instances[idx].transRow2;
	insMat[3] = instances[idx].transRow3;
	float4x4 primMat = primitives[primIdx].transform;
	float4x3 worldMat = mul(primMat, insMat);
	float4 pos = mul(worldMat[3], float4(0,0,0,1));
	float cullDistance = primitives[primIdx].cullDistance;
	uint firstIndex = primitives[primIdx].firstIndex;
	uint indexCount = primitives[primIdx].indexCount;

	indirectDraws[idx].firstIndex = firstIndex;
	indirectDraws[idx].indexCount = indexCount;
	indirectDraws[idx].vertexOffset = 0;
	indirectDraws[idx].firstInstance = 0;
	// Check if object is within current viewing frustum
	if (frustumCheck(pos, 0.0) || distance(pos.xyz, view.cameraPos.xyz) < cullDistance)
	{
		indirectDraws[idx].instanceCount = 1;
	}
	else
	{
		indirectDraws[idx].instanceCount = 0;
	}
}